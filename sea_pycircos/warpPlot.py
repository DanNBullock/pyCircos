#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 20 16:53:01 2022

@author: dan
"""

import seaborn as sns
import numpy as np
import pandas as pd
import matplotlib

from matplotlib.transforms import Affine2D
import mpl_toolkits.axisartist.floating_axes as floating_axes
import numpy as np
import mpl_toolkits.axisartist.angle_helper as angle_helper
from matplotlib.projections import PolarAxes
from mpl_toolkits.axisartist.grid_finder import (FixedLocator, MaxNLocator,
                                                 DictFormatter)
import matplotlib.pyplot as plt

matplotlib.pyplot.close('all')

#generate random data np uni
# xVals=np.random.uniform(low=0, high=np.pi*.5, size=100)
# yVals=np.random.uniform(low=1, high=2, size=100)
xVals=np.random.rand(1000)
yVals=np.random.rand(1000)
xRange=[0,1]
yRange=[0,1]


#create an array
sampleData=np.asarray([xVals,yVals]).T
#populate dataframe
sampleDataFrame=pd.DataFrame(data=sampleData,columns=['xVals','yVals'])
#initialize figure and axis
#fig, ax = matplotlib.pyplot.subplots()
fig=matplotlib.pyplot.figure(figsize=(8, 8))

#get the dimensions of the figure
figDims=fig.get_size_inches()
#find the center coordinate
figCenterCoord=figDims/2

ringNumber=2
#establish Figure Number
figureNumber=6
#find radians dedicated to each
spaceForEach=(2*np.pi)/figureNumber
#create boundaries in radian space
all_rBounds=np.arange(0,2*np.pi,spaceForEach)

def generateTestDataFrame(dataPoints=1000):
    """
    Quick testing function to generate an vertically oriented data frame for
    use with function testing

    Parameters
    ----------
    dataPoints : int, optional
        The desired number of data points for the test dataframe.
        The default is 1000.

    Returns
    -------
    sampleDataFrame : pandas dataframe
        A test data frame with 1000 random values between 1 and 0 in the
        'xVals' and 'yVals' columns

    """

    
    import pandas as pd
    import numpy as np
    xVals=np.random.normal(.5,.2,dataPoints)
    yVals=np.random.normal(.5,.2,dataPoints)

    #create an array
    sampleData=np.asarray([xVals,yVals]).T
    #populate dataframe
    sampleDataFrame=pd.DataFrame(data=sampleData,columns=['xVals','yVals'])
    
    return sampleDataFrame

def generateNTestDataFrames(nDataFrames,dataPoints=1000):
    """
    Generate a list of [nDataframes] with [dataPoints] number of datapoints
    each

    Parameters
    ----------
    nDataFrames : int
        The number of dataframes to generate.
    dataPoints : TYPE, optional
        The desired number of data points for each test dataframe. The default is 1000.

    Returns
    -------
    dfList : List of pandas DataFrames
        A list of pandas dataframes, as generated by generateTestDataFrame

    """
    
    if isinstance(nDataFrames, int):
        dfList=[generateTestDataFrame(dataPoints) for iRequests in range(nDataFrames)]
    else:
        raise Exception('input nDataFrames value not an integer')
    
    return dfList
    
def rescaleDFcolumn(inputDataframe, columnLabel,newLowerBound,newUpperBound,forceOldMinBound=None,forceOldMaxBound=None):
    """
    

    Parameters
    ----------
    inputDataframe : pandas DataFrame
        The pandas dataframe containing the column data that is to be
        scaled
    columnLabel : string
        the column label assocaiated with the values that are to be scaled
    newLowerBound : float
        The lesser of the two new bounds.
    newUpperBound : float
        The greater of the two new bounds.
    forceOldMinBound : float, optional
        If a value is entered for forceOldMinBound, it will be treated as the 
        minimum bound of the input data column, irrespective of the data 
        itself. The default is None.
    forceOldMaxBound : float, optional
        If a value is entered for forceOldMaxBound, it will be treated as the 
        maximum bound of the input data column, irrespective of the data 
        itself. The default is None.

    Returns
    -------
    inputDataframe : pandas DataFrame
        The same DataFrame as was input, except with the specified column's
        data having been scaled within the provided bounds in accordance with
        the input forced bounds, if any.

    """
    import numpy as np
    import pandas as pd
    import warnings

    #compute the new range
    newRange=np.abs(newUpperBound)-np.abs(newLowerBound)

    #if no forceOldMinBound were entered infer from the data
    if forceOldMinBound==None:
        minBound=np.min(inputDataframe[columnLabel])
    else:
        if forceOldMinBound > np.min(inputDataframe[columnLabel]):
            warnings.warn('forceOldMinBound greater than actual data max value')
        minBound=forceOldMinBound
    
    #if no forceOldMinBound were entered infer from the data
    if forceOldMaxBound==None:
        maxBound=np.max(inputDataframe[columnLabel])
    else:
        if forceOldMaxBound < np.max(inputDataframe[columnLabel]):
            warnings.warn('forceOldMaxBound less than actual data max value')
        maxBound=forceOldMaxBound
        
    #find the value range covered by the input dataframe column
    dfRange=np.abs(maxBound)-np.abs(minBound)
    
    #compute the conversion factor
    conversionFactor=dfRange/newRange
    
    #rescale the column using the conversion factor and the new minimum bound
    inputDataframe[columnLabel]=np.add(np.divide(inputDataframe[columnLabel],conversionFactor),newLowerBound)
    
    #print('Column ' + columnLabel + ' scaled to bounds ' + str(newLowerBound) + ' to ' + str(newUpperBound) + ' from ' + str(minBound) + ' to ' + str(maxBound) )
    #print('New data min/max = ' + str(np.min(inputDataframe[columnLabel])) + ' / ' + str(np.max(inputDataframe[columnLabel])) )
    return inputDataframe
    

def transformDataToWedgeRange(sampleDataFrame, xLabel, yLabel,lowerRBound,upperRBound,innerRadius,outerRadius,forceBounds=None):
    """
    Converts input dataframe (or at least the specified columns of such) to be 
    proportionally contained within the specified area of the bounds of the
    radially converted plot.

    Parameters
    ----------
    sampleDataFrame : pandas dataframe
        The pandas dataframe containing the information that is desired to be
        plotted
    xLabel : string
        The column label assocaiated with the values that are desired to serve
        as the x values in the requested plot
    yLabel : string
        The column label assocaiated with the values that are desired to serve
        as the y values in the requested plot
    lowerRBound : float, between 0 and 2*pi (thus in radians)
        The lesser of the two lateral bounds of the requested plot, as
        instantiated in the cocentric arc segment plot(s)
    upperRBound : float, between 0 and 2*pi (thus in radians)
        The greater of the two lateral bounds of the requested plot, as
        instantiated in the cocentric arc segment plot(s)
    innerRadius : float, in units of the associated figure size (e.g. inches)
        The closer (relative to the figure center) of the two vertical bounds
        of the requested plot, as instantiated in the cocentric arc segment
        plot(s).
    outerRadius : float, in units of the associated figure size (e.g. inches)
        The further (relative to the figure center) of the two vertical bounds
        of the requested plot, as instantiated in the cocentric arc segment
        plot(s).
    forceBounds : array, 4 values in length, floats, optional
        The minimum and maximum boundaries for the data associated with the
        input x and y valus from the dataframe. The default is None.
        Ordering: xMin, xMax, yMin, yMax

    Returns
    -------
    sampleDataFrame : pandas dataframe
        The same input dataframe as entered into the function, however the 
        columns specified in the input xLabel and yLabel variables have been 
        proportionally (and thus in a relation preserving fashion) converted
        into a range which will fit the radial bounds specified in the 
        lowerRBound, upperRBound, innerRadius, and outerRadius variables

    """
    import numpy as np
    import pandas as pd

    #if no forceBounds were entered
    if forceBounds==None:
        #find the value range covered by each dimension of the input 
        #dataframe data
        dfXrange=np.max(sampleDataFrame[xLabel])-np.min(sampleDataFrame[xLabel])
        dfYrange=np.max(sampleDataFrame[yLabel])-np.min(sampleDataFrame[yLabel])
        
        #find the value range covered by the input radial bounds
        inputRadianRange=upperRBound-lowerRBound
        inputRadiusRange=outerRadius-innerRadius
        
        #compute the conversion factors using these values
        xConversionFactor=dfXrange/inputRadianRange
        yConversionFactor=dfYrange/inputRadiusRange
        
        #divide the origional dataframe column by this value to get the converted
        #plot range
        outDataFrame=pd.DataFrame()
        outDataFrame[xLabel][xLabel]=np.add(np.divide(sampleDataFrame[xLabel],xConversionFactor),np.min(sampleDataFrame[xLabel]))
        outDataFrame[yLabel]=np.add(np.divide(sampleDataFrame[yLabel],yConversionFactor),np.min(sampleDataFrame[yLabel]))
    
    else:      
        #if force bounds were entered, do essentially the same as above, except
        #don't infer the bounds from the input dataframe values.
        dfXrange=forceBounds[1]-forceBounds[0]
        dfYrange=forceBounds[3]-forceBounds[2]
        
        #find the value range covered by the input radial bounds
        inputRadianRange=upperRBound-lowerRBound
        inputRadiusRange=outerRadius-innerRadius
        
        #compute the conversion factors using these values
        xConversionFactor=dfXrange/inputRadianRange
        yConversionFactor=dfYrange/inputRadiusRange
        
        #divide the origional dataframe column by this value to get the converted
        #plot range
        outDataFrame=pd.DataFrame()
        outDataFrame[xLabel]=np.add(np.divide(sampleDataFrame[xLabel],xConversionFactor),lowerRBound)
        outDataFrame[yLabel]=np.add(np.divide(sampleDataFrame[yLabel],yConversionFactor),innerRadius)
    
    return outDataFrame

def computeArcBoundingBox(fig,arcBound1,arcBound2,radius1,radius2):
    """
    Computes the appropriate bounding box for the specified arc-segment,
    such that the segment can be accurately / reliably placed in a 
    co-centrically oriented arrangment relative to other 

    Parameters
    ----------
    fig : figure handle
        The figure handle of the figure that the arc plot is to be placed on.
    arcBound1 : float, between 0 and 2*pi (thus in radians)
        The lesser of the two lateral bounds of the requested arc section.
    arcBound2 : float, between 0 and 2*pi (thus in radians)
        The greater of the two lateral bounds of the requested arc section.
    radius1 : float, in units of the associated figure size (e.g. inches)
        The closer (relative to the figure center) of the two vertical bounds
        of the requested plot, as instantiated in the cocentric arc segment
        plot(s).
    radius2 : float, in units of the associated figure size (e.g. inches)
        The further (relative to the figure center) of the two vertical bounds
        of the requested plot, as instantiated in the cocentric arc segment
        plot(s).
    Returns
    -------
    list of [xMin,  xMax, yMin, yMax]
        A 4 value list specifying the lateral and vertical boundaries of the
        bounding box which surrounds the arc section specified in the input
        variables.

    """
    import numpy as np
    
    #this assumes that the figure is square, which it should be for a circular
    #plot
    #obtain the center coordinate of the figure and subsequent circle
    figCenterCoord=fig.get_size_inches()/2
    
    #quick confersion function for polar to cartesian coordinates
    def pol2cart(rho, phi):
        x = rho * np.cos(phi)
        y = rho * np.sin(phi)
        return(x, y)
    
    #compute the radian coordinates of the cardinal points of the circle
    cardinalPoints=np.arange(0,(2*np.pi),(2*np.pi)/4)
    
    #compute the cartesian coordinates of the cardinal points for both the
    #inner and outer circle
    cardinalCoords1=np.asarray([pol2cart(radius1, iPoints) for iPoints in cardinalPoints])
    cardinalCoords2=np.asarray([pol2cart(radius2, iPoints) for iPoints in cardinalPoints])
    
    #check to see if the input radian bounds contain one of these cardinal points
    cardinalBoundsCheck=[ iCardinalPoints>arcBound1 and iCardinalPoints<arcBound2  for iCardinalPoints in cardinalPoints ]
    
    #compute the verticies of the arc delineated by the input bound values
    arcCoords11=pol2cart(radius1, arcBound1)
    arcCoords12=pol2cart(radius1, arcBound2)
    arcCoords21=pol2cart(radius2, arcBound1)
    arcCoords22=pol2cart(radius2, arcBound2)
    
    #stack the coordinates of the arc boundaries into an array
    arcCoordsArray=np.vstack((arcCoords11,arcCoords12,arcCoords21,arcCoords22))
    
    #stack the coordinates of the arc boundaries, along with the included 
    #cardinal points (should there be any) into an array
    coordsToCheck=np.vstack((cardinalCoords1[cardinalBoundsCheck],cardinalCoords2[cardinalBoundsCheck],arcCoordsArray))
    
    #check this array for its max and minimum boundaries in both dimensions
    xMin=np.min(coordsToCheck[:,0])
    xMax=np.max(coordsToCheck[:,0])
    yMin=np.min(coordsToCheck[:,1])
    yMax=np.max(coordsToCheck[:,1])
    
    return [xMin, xMax, yMin, yMax]


def setup_ArcedAxes(fig, dataBounds, transform=None ):
    """
    This function establishes the figure axes for a arc section, the figure
    bounds of which are specified in dataBounds 

    Parameters
    ----------
    fig : figure handle
        The figure handle of the figure that the axes will be palced in
    dataBounds : array or list-like of 4 floats,
        These values indicate the boundaries of the arc-shaped figure
        axes which will be generated by this function.
        - The first two values correspond to the lateral boundaries of the
        subplot (in radians)
        - The last two values correspond to the radial boundaries of the
        subplot (units of the source figure size)

    Returns
    -------
    ax1 : subplot axes
        The desired figure axes handle
    aux_ax : auxillary / parasite 
        Also the desired figure axes handle (I don't know what the difference
        is, honestly)

    """
    #setup transform method, polar transform
    if transform==None:
        tr = PolarAxes.PolarTransform()
    else:
        tr = transform + PolarAxes.PolarTransform()
    #get pi from numpy
    pi = np.pi
    
    #compute the coordinates of the bounding box of the current subplot
    bboxCoords=computeArcBoundingBox(fig,dataBounds[0],dataBounds[1],radius1=dataBounds[2],radius2=dataBounds[3])

    #compute the center coordinate of the figure / circle
    figCenterCoord=fig.get_size_inches()/2
    #bounding box coorinates actually have to be entered in as a value between
    #1 and 0, so we need to make a conversion
    #furthermore, the bounding box coordinates are given in a cartesian schema
    #where the center point is 0,0 (and there are negative values)
    #in order to work around this, we add the center figure coord to offset this
    #and then scale by the size of the (presumably square) figure
    shiftedScaledBBoxes=(bboxCoords+figCenterCoord[0])/fig.get_size_inches()[0]
    
    #set up a grid helper entity
    #may need to play around with the ordering of these, depending on what
    #sequence the extreemes are expecting to be entered in
    grid_helper = floating_axes.GridHelperCurveLinear(
        tr, extremes=( dataBounds[0], dataBounds[1], dataBounds[2], dataBounds[3]),
        grid_locator1=None,
        grid_locator2=None,
        tick_formatter1=None,
        tick_formatter2=None)

    #establish the floating figure axes via subplot
    ax1 = fig.add_subplot(111, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)
    
    #turn off all of the tics and everything
    #this can be changed in the production version to be a bit more adaptable
    ax1.axis["top"].toggle(all=False)
    ax1.axis["bottom"].toggle(all=False)
    ax1.axis["left"].toggle(all=False)
    ax1.axis["right"].toggle(all=False)
    
    #find the current bounding box
    currentBBox=matplotlib.transforms.Bbox.from_extents(shiftedScaledBBoxes[0],shiftedScaledBBoxes[2],shiftedScaledBBoxes[1],shiftedScaledBBoxes[3])
    
    #set the axis 
    ax1.set_position(currentBBox)
    #set the margins to none
    ax1.margins(0,tight=True)

    # create a parasite axes with the polar coordinate framework
    #what the heck is a parasite axis?
    aux_ax = ax1.get_aux_axes(tr)
    #set this location to the specified bounding box
    #maybe not necessary as probably inherited from parent axes
    aux_ax.set_position(currentBBox)
    #also reduce the margins to none
    aux_ax.margins(0,tight=True)

    #not sure, but ok
    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax
    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is
    # drawn twice, and possibly over some other
    # artists. So, we decrease the zorder a bit to
    # prevent this.
    # (as quoted from source matplotlib documentation)
    return ax1, aux_ax

def plotFullRing(dfList, all_rBounds, innerBound, outerBound,seabornPlotType, forceDataBounds=None, **seabornPlotkwargs):
    
    import re
    import seaborn as sns
    import itertools
    import numpy as np
    #lets do a clever check on the input seabornPlotkwargs variable
    #under normal circumstances this would be returned as a dictionary where
    #the keys are the keywords and the values are their arguments/settings
    #HOWEVER
    #for outer loops that implement this, it's not possible to pass along the
    #elements of the seabornPlotkwargs variable in the standard format:
    #i.e. [argument=[value]
    #what we might want to do instead is go ahead and pass along a dictionary
    #*ALREADY* (which works well for loops and such).  In such a case, we can
    #just stipulate that seabornPlotkwargs would be a 1 item long dictionary
    #with the key 'dict', and the value being the seabornPlotkwargs dictionary
    #itself.
    #a happy comprimize/hack
    if np.all([len(seabornPlotkwargs)==1, isinstance(list(seabornPlotkwargs.values())[0],dict)]):
        #go ahead and treat seabornPlotkwargs['dict'] as the dict
        seabornPlotkwargs=seabornPlotkwargs['dict']

    #test if the input seabornPlotType is a valid plot from seaborn
    #only kind of an effective test, some of these won't work on the ring
    #structure
    #get the list of seaborn functions
    seabornFunctions=dir(sns)
    #find the ones that have 'plot' at the end of the function name
    #not exact, but an approximation of the avaialble plotting functionalities
    #looking for function names that end in plot
    r = re.compile('plot$')
    #get a boolean vector for these
    plotFunctionsBool=[not re.search(r, iFunctions)==None for iFunctions in seabornFunctions]
    #return a list of the valid seaborn function names
    validPlotFunctionNames=list(itertools.compress(seabornFunctions,plotFunctionsBool))
    #now throw an exception if the requested seaborn plot type isn't in the list
    if not seabornPlotType in validPlotFunctionNames:
        raise Exception('Requested seaborn plot type ' + seabornPlotType + ' not valid.  Valid plot types: \n\n'+ ' '.join(validPlotFunctionNames))

    #check the input dataFrame list and all_rBounds to ensure appropriate numbers
    #you need a left and right bound for each plot
    if len(dfList) == len(all_rBounds)+1:
        print ('Plotting ' + str(len(dfList)) + ' radial ' + seabornPlotType + ' subsections.' )
    elif len(dfList) == len(all_rBounds):
        import warnings
        #I don't understand the manner in which warnings are printed to the terminal
        #this appears in the terminal AFTER the later print statement
        warnings.warn( str(len(all_rBounds)) + ' bounds provided for ' + str(len(dfList)) + ' dataframes \n assuming a complete circumference and inferring final bound from first bound.')
        #there might be some typing issues to take care of here, in case a list
        #vs an array is input
        if isinstance(all_rBounds,np.ndarray):
            all_rBounds=list(all_rBounds)
        all_rBounds.append(all_rBounds[0]+np.pi*2)
        print(str(all_rBounds))
    else :
        raise Exception('Incorrect number of bounds, '+ str(len(all_rBounds)) + 'bounds provided for ' + str(len(dfList)) + ' dataframes.')

    #next we check the bounds of the data itself, first is checking if a
    #omnibus forceDataBounds specification was provided
    if not forceDataBounds==None:
        #check to make sure it's of length 4
        if not len(forceDataBounds)==4:
            raise Exception('Incorrect number of bounds ' +str(len(forceDataBounds))+  'provided for "forceDataBounds" \n Please input "forceDataBounds" thusly: [xMin, xMax, yMin, yMax]')
        else:
            #if four values were provided
            dataBounds=forceDataBounds
            
    #otherwise
    else:
        #initialize a list for the databounds
        #fill it with none to start, to indicate default being no bounds being
        #being applied
        dataBounds=[None, None, None, None]
        
        #begin the complicated task of infering the bounds fromm the data
        #check to ensure that range of y values is sufficiently reasonable to
        #normalize to the same range.  In other words, ensure that variation in Y 
        #ranges is within a half magnitude of order
        #HERE'S A PROBLEM THOUGH, we're presuming a Y value, it could be
        #that the requested plot is "histplot" or something like that, and so
        #we would need to check the x counts
        
        
        if 'y' in seabornPlotkwargs:
            #check to make sure it's a string and not a vector
            #it shouldn't be a vector though given that we're inputting tables
            if isinstance(seabornPlotkwargs['y'],str):
                yRanges=[np.ptp(idfList[seabornPlotkwargs['y']].to_numpy()) for idfList in dfList] 
            else:
                raise Exception('Invalid y data indicator, ' + str(seabornPlotkwargs['y']) + ', provided for ' + seabornPlotType )
            #set height ranges to relevant variable
            heightRanges=yRanges

            minMaxArray=[np.min(idfList[seabornPlotkwargs['y']].to_numpy()) for idfList in dfList] + [np.max(idfList[seabornPlotkwargs['y']].to_numpy()) for idfList in dfList]
        else:
            #figure out how to do this for things like histplot
            #if you're ONLY being passed the x data
            #then the only examples I can find of this are of hist plots,
            #so maybe this is a safe assumption
            minMaxArray=[]
            if 'x' in seabornPlotkwargs:
                #you'll need to do some sort of estimation of the 
                #frequency of the relative bins, but this presupposes that
                #you know the number of bins before the data is plot...
                #seaborn talks about this: " The default bin size is determined
                #using a reference rule that depends on the sample size and
                #variance.  Don't know how to get ahold of that.
                for iDataFrames in dfList:
                    hist,bin_edges =np.histogram(iDataFrames[seabornPlotkwargs['x']].to_numpy(),bins='auto')
                    
                    minMaxArray=minMaxArray + [np.max(hist)]
                #these are effectively the yRanges as well
                heightRanges=minMaxArray
                #to ensure we get the minimum of zero in there
                minMaxArray=minMaxArray + [0]
                
                #an added complication comes up if they are using another
                #column as a grouping variable, via "hue"
                # if 'hue' in seabornPlotkwargs:
                #     print('Height scaling not yet implemented for univariate data')
                #actually this doesn't impact the max Y value, as max Y value 
                #would be across categories

        #check to see about order of magnitude of y ranges, using .5 order of magnitude
        #as threshold
        if np.divide(max(heightRanges),min(heightRanges))<5:
            #if the range is sufficiently small, then we'll implement a forced data
            #bounds based on the maximum data range of the data
            dataBounds[2]=np.min(minMaxArray)
            dataBounds[3]=np.max(minMaxArray)
        
        #begin the plotting
        for iBoundaries in range(len(dfList)):
            #get the boundaries for the current arc segment of the figure
            currentBounds = [all_rBounds[iBoundaries], all_rBounds[iBoundaries+1], innerBound, outerBound ]
            #feed those into the axis setup function
            ax1, aux_ax=setup_ArcedAxes(fig, currentBounds)
            
            #we're not forcing bounds here for this test, because apparently our data is outside 0 - 1 bounds
            #forceBounds=[0,1,0,1]
            
            #scale the y data if it's available
            if 'y' in seabornPlotkwargs:
                transformedData=rescaleDFcolumn(dfList[iBoundaries], columnLabel='yVals',newLowerBound=currentBounds[2],newUpperBound=currentBounds[3],forceOldMinBound=dataBounds[2],forceOldMaxBound=dataBounds[3])
            #scale the x data
            if 'x' in seabornPlotkwargs:
                transformedData=rescaleDFcolumn(dfList[iBoundaries], columnLabel='xVals',newLowerBound=currentBounds[0],newUpperBound=currentBounds[1],forceOldMinBound=dataBounds[0],forceOldMaxBound=dataBounds[1])
       
            #form up the call string
            #begin by converting the seabornPlotkwargs to a string
            composedSeabornPlotkwargs='data=transformedData, ax=aux_ax, '
            for iArg in range(len(seabornPlotkwargs)):
                #gotta add a little robustness in here for string and nonstring values
                currKey=list(seabornPlotkwargs.keys())[iArg]
                if isinstance (seabornPlotkwargs[currKey],str):
                    #if it's a string, add an extra layer of quotes to preserve stringyness
                    currentValue='"'+seabornPlotkwargs[currKey]+'"'
                else:
                    #otherwise, simply convert it into a string
                    currentValue=str(seabornPlotkwargs[currKey])
                
                composedSeabornPlotkwargs += currKey + '='+currentValue+', '
            
            #remove the trailing bit there, as we added an unnecessary ', '
            composedSeabornPlotkwargs=composedSeabornPlotkwargs[0:-2]
            functonCall='sns.'+seabornPlotType+'('+composedSeabornPlotkwargs+')'
            eval(functonCall)
            
    
    
#borrow chord diagram from here
#https://github.com/tfardet/mpl_chord_diagram

#begin the test
fig=matplotlib.pyplot.figure(figsize=(10, 10))
#set ring width
ringWidth=2
#specify the numbner of plots
figureNumber=6
#find radians dedicated to each
spaceForEach=(2*np.pi)/figureNumber
#create boundaries in radian space
all_rBounds=np.arange(0,2*np.pi,spaceForEach)
#compute ring borders
ringBorders=np.arange(ringWidth,fig.get_size_inches()[0]+ringWidth,ringWidth)

plotList=['kdeplot','histplot','scatterplot','kdeplot']
seabornPlotkwargs1={'x':'xVals', 'y':'yVals','fill':True, 'cmap':'rocket'}
seabornPlotkwargs2={'x':"xVals", 'y':'yVals', 'cmap':'mako'}
seabornPlotkwargs3={'x':"xVals", 'y':'yVals'}
seabornPlotkwargs4={'x':"xVals", 'fill':True}
seabornPlotkwargsList=[seabornPlotkwargs1,seabornPlotkwargs2,seabornPlotkwargs3,seabornPlotkwargs4]
#I don't know, seems inelegegant, but to be safe
forceDataBounds=None


for iRings in range(len(ringBorders)):
    #create the dataframes
    dfList= generateNTestDataFrames(figureNumber,dataPoints=1000)
    #plot it    
    plotFullRing(dfList, all_rBounds, ringBorders[iRings], ringBorders[iRings+1],plotList[iRings], forceDataBounds=None, **seabornPlotkwargsList[iRings])




#     #plot it    
#     plotFullRing(dfList, all_rBounds, ringBorders[iRings], ringBorders[iRings+1],plotList[iRings], forceDataBounds=None, x="xVals", y='yVals',fill=True, cmap='rocket')
   
# dfList= generateNTestDataFrames(figureNumber,dataPoints=1000) 
# plotFullRing(dfList, all_rBounds, 4, 6,'histplot', forceDataBounds=None, x="xVals", y='yVals', cmap='mako')
     
# dfList= generateNTestDataFrames(figureNumber,dataPoints=1000) 
# plotFullRing(dfList, all_rBounds, 6, 8,'histplot', forceDataBounds=None, x="xVals", y='yVals', cmap='mako')
# # for iRingTest in range(len(ringBorders)-1):
# #     for iBoundaries in range(figureTestNumber):
#         dataBounds = [boundaries[iBoundaries], boundaries[iBoundaries+1], ringBorders[iRingTest],ringBorders[iRingTest+1] ]
    
#         ax1, aux_ax=setup_ArcedAxes(fig, dataBounds)
        
#         testData=generateTestDataFrame()
#         forceBounds=[0,1,0,1]
     
#         transformedData=transformDataToWedgeRange(testData, 'xVals', 'yVals', lowerRBound=dataBounds[0],upperRBound=dataBounds[1],innerRadius=dataBounds[2],outerRadius=dataBounds[3],forceBounds=forceBounds)
        
#         # #test out various plots
#         if iRingTest == 0 :
#             sns.kdeplot(data=transformedData, x='xVals', y='yVals',ax=aux_ax,fill=True, cmap="rocket")
#         elif iRingTest == 1 :    
#             sns.histplot(data=transformedData,x='xVals', y='yVals', ax=aux_ax, bins=50, cmap="mako")
        
#         elif iRingTest == 2 :
#             sns.kdeplot(data=transformedData, x='xVals', y='yVals',ax=aux_ax,fill=True, cmap="cubehelix")
            
#         elif iRingTest == 3 :
#             sns.scatterplot(data=transformedData,x='xVals', y='yVals', ax=aux_ax)
           
        








